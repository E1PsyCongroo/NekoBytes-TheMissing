# Proj1 MyMalloc

## 项目总览

在本项目中，你需要在给定框架下使用C语言编写一个动态存储分配器，也就是实现你自己的malloc、free和realloc。

我们推荐您在给定框架下实现隐式自由块链表的First fit算法，保证正确性即可

对于有能力有追求的同学，可以尝试实现隐式链表，并实现First fit、Next fit、Best Fit等算法，比较并优化你的malloc

或者你也可以尝试实现隔离存储的链表，设计你自己的匹配算法

## 开始之前

如果你还不清楚malloc是什么，如何使用malloc

请阅读：<https://zh.cppreference.com/w/c/memory/malloc>

如果你还不清楚malloc是如何运作的

请阅读同目录下的basic_note.md

本实验改编自CSAPP课程的lab，如果你想体验原汁原味的抓狂体验或者想要实现更接近底层更高效的内存分配器

请使用CSAPP课程网站资源：<https://csapp.cs.cmu.edu/3e/labs.html>

## 项目概述

### mm.c

这是你需要修改完善的，并且是本项目初始自带的文件中你**唯一**可以修改的文件，**不要修改其余文件，也不要修改该文件中不需要修改的部分**

你的主要目标是完善四个函数，实现他们的功能，并获取更高的分数

#### int mm_init(void)

评测开始时，会调用该函数，你可以在该函数中实现程序的初始化，例如申请初始空间,初始化链表等

返回值为0表示正常初始化

#### void *mm_malloc (size_t size)

传入申请空间大小size，返回指向符合需求的空间的void*指针

#### void mm_free (void *ptr)

传入需要释放的空间的起始地址，不需要返回值

通过该函数的传入信息用你的方式维护你的结构体链表

#### void *mm_realloc(void*ptr, size_t size)

传入原数据所在空间地址void* ptr、新的空间区域大小size

1. 如果ptr为NULL，此调用等价于mm_malloc(size)
2. 如果size为0，此调用等价于mm_free(ptr)
3. 否则，为其重新分配一片空间并继承原数据,若新空间大小小于原空间大小，则继承靠前的数据（**警惕数据污染**）

### mm.h

可以修改该文件为你的代码提供支持，不修改该文件也可完成该项目

### mdriver.c

用于测试你的程序正确性，不要修改该文件，你不会用到其中的成员

### traces

默认的测试数据集，不要修改该文件夹下的文件，你可以按照规范添加自己的测试数据，并使用mdriver的命令行参数运行自创数据集

### fsecs.c/h clock.c/h fcyc.c/h ftimer.c/h

与计时相关，不要修改该文件，你不会用到其中的成员

### memlib.c/h

与堆栈空间分配相关，不要修改该文件，你会用到其中的一些成员函数

#### mem_sbrk

传入需要扩展的空间的大小incr，在原空间的基础上在堆栈上申请新空间，可以视作连续的空间

#### void *mem_heap_lo(void)

返回指向当前堆栈最前部的指针

#### void *mem_heap_hi(void)

返回指向当前堆栈最后部的指针

#### size_t mem_heapsize(void)

返回当前堆大小（单位：字节）

## 检验程序

在项目目录下运行make生成可执行文件mdriver

可执行文件mdriver接受以下命令行参数：

1. -t \<tracedir\> 使用指定文件夹下测试数据
2. -f \<tracefile\> 使用指定文件作为测试数据
3. -h 打印命令行参数说明
4. -l 同时运行C标准库中的malloc，但是不统计其空间利用率
5. -v 输出详细数据
6. -V 输出更详细的数据

校验程序对以下事项提出正确性要求：

1. 你分配的块必须与字节对齐，也就是你分配的块的地址必须是8的倍数
2. 你分配的块不能超过当前分配的堆的大小
3. 分配的块之间不能有重叠
4. realloc需要正确继承数据

当mdriver输出错误信息时，你可以打开mdriver.c寻找错误信息的来源已经对应的注释来获取信息

## 编程事项

1. 不要定义任何新的全局变量或静态变量
2. 出于简化难度的目的，你可以使用malloc，但是请在必要用的地方使用并记得free
3. 不要修改你不应该修改的东西

## 提示

### 一致性检查

此处一致性特指行为一致性，也就是说你应当检查你的程序的行为是否符合预期

一致性检查会降低程序运行的效率，但是对你的调试大有裨益，你可以在通过测验程序之前保持一致性检查的进行

***错误的假设是调试的痛苦根源😭***

你可能需要对一下事项进行一致性检查：

1. 释放的空间得到了正确的维护吗？废弃的空间会导致你的空间利用率下降，这或许不会引发错误但这是严重的问题
2. 相邻的自由块得到了合并吗？没有合并的自由块不仅会降低你的空间利用率(明明能分配但是没分配)还会降低你的时间效率
3. 每个区块都在你的链表中吗，区块之间是否存在重叠（提示：你可以通过检查相邻地址之差是否与块大小匹配）

### 单元测试

单元测试是软件开发过程中的一种测试方法，旨在验证软件中最小可测试单元（通常是函数、方法或类）的正确性。

对成熟的项目而言，进行单元测试是必须的。

想象一下，当项目的运行结果偏离预期时，你拥有一百个组件。

哪怕其中只有三个组件出错，排查定位时也存在$\binom{3}{100}$种可能性。

因此，在你完成一个组件时立刻对其进行功能测试，能大大降低DEBUG的开销。

本项目为你提供了一些现成的简单的单元测试，我们鼓励你针对自己代码潜在的问题撰写自己的单元测试。

***警告⚠️:通过单元测试并不意味着你的函数实现是绝对正确的***

***每个人的实现都不一样，你可能需要自行设计单元测试***

如果你需要设计自己的单元测试，你可能需要了解[这个](https://zh.cppreference.com/w/c/error/assert)。

打开同目录下mtest.c阅读注释了解更多。

### 善用gdb

调代码切忌我以为、我认为、这应该

***我们C语言没有任何bug，一切以实际运算为准***

当代码崩溃时，如果无法通过一致性测试和调试输出找到错误，请使用gdb。

因为你有可能犯了一个极为基本的错误，比如数组越界，解引用空指针，gdb擅长找到这样的错误。

## 让我们开始吧

如果你还没有阅读basic_note.md，请阅读同目录下的basic_note.md

对于代码能力良好的同学，可以直接打开mm.c，阅读代码注释，尝试完成本项目

你可以打开同目录下的guide.md,参考函数实现思路，使用现成的单元测试辅助项目完成
