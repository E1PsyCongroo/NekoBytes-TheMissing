# 猴子🐒也能看懂的Proj1实现指南

阅读同目录下mtest.c中的注释了解单元测试的使用方法

如果你认为你需要一些辅助与提示完成该项目，请阅读下文

我们鼓励你在不阅读下文的情况完成该项目

（当然我们鼓励你使用预设的单元测试，减少一些你的机器劳作）

## Task1——遍历链表

在本Task中，你需要完成`mm.c`中的函数:`find_fit`与`find_by_ptr`

### find_fit

#### 功能描述

传入需分配的空间的大小`size`

顺序遍历当前链表

当找到满足要求的块时返回指向该块的指针

否则返回空指针

#### 实现思路

顺序遍历链表，检查块的`empty`和`size`属性

### find_by_ptr

#### 功能描述

传入指向堆空间地址的指针`ptr`

顺序遍历链表

返回指向该地址的块（维护该空间地址信息的块）的指针

#### 实现思路

顺序遍历链表，检查块的`ptr`属性

## Task2——分配空间

在本Task中，你需要完成`mm.c`中的函数:`place`

### place

#### 功能描述

传入空闲块指针`bk`，传入分配空间大小`size`

将空闲块指针`bk`靠前的`size`Byte空间标记为已分配

修改原空闲块的信息

为新的占用块分配块结构体进行维护

维护链表的前驱后继

返回分配空间的起始地址

#### 实现思路

考虑创建新的块结构体维护分配后处于被占用状态的空间

更新块结构体的相关属性

#### 提示

- 注意`size`和bk的`size`恰好相同的情况
- 注意bk为头指针所指块的特殊情况
- 你可以对指针进行算数运算，以推算剩余的空闲堆空间的起始地址
- 对指针解引用前请注意其是否可能为空指针

## Task3——合并空闲块

在本Task中，你需要完成`mm.c`中的函数:`coalesce`

### coalesce

#### 函数功能

传入空闲块指针`bk`

将该空闲块与相邻的空闲块合并

返回指向合并后的块的指针

#### 函数思路

你可能需要考虑四种情况：

- 前无空块后无空块
- 前无空块后有空块
- 前有空块后无空块
- 前有空块后有空块

具体的步骤类似传统双端队列的删除节点

但是在该项目中你需要维护`ptr`和`size`

#### 提示

- 你仍旧需要在对指针解引用前确认其是否为空指针
- 在完成代码后，四种情况的代码可能会有所重复，你可以使用更少的条件控制语句实现该函数吗
- 注意特判头指针和尾指针的转移情况
- 注意释放不再使用的块结构体指针

## Task4——申请空间

在本Task中，你需要完成`mm.c`中的函数:`extend_heap`

### extend_heap

#### 函数功能

传入需要向堆空间申请的空间大小`size`

将申请得到的空间用`block`结构体并接入链表尾部

#### 函数思路

使用项目提供的mem_sbrk向堆申请空间

使用块结构体维护新空间的信息

将块插入链表末尾

#### 提示

- 向结尾插入一个新的空闲块，我们可能需要做什么事情？
- 注意特判当前链表为空的情况

## TaskFin——完成项目

在需要完成的函数中对上述已经实现的函数进行简单的调用

对状态进行一些基本处理

这个项目便大功告成了

make后运行mdriver试试吧

相信无需阐述、无需提示、无需预设的单元测试（当然我们鼓励你自己去写一个）

你已经有能力完成这个项目

加油💪胜利就在眼前🏆
