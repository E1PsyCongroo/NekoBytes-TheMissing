# P17

指针的一个功能就是充当变量的“别名”
通过指针储存的地址可以修改指向变量的值，那么解引用符*可以获取这个地址空间对应指针类型的值。例如：
看起来有些奇怪？
为什么地址靠前的部分显示了
数位靠低的数据？
请自行了解大端序与小端序😊

# P18

现在我们知道了，一个指针通常对应了两个值：指针本身指向的地址与指向地址处的数据。
这意味着我们对指针赋值时需要区分需要修改的是哪个值
对于前者我们直接使用指针名，而后者需要在指针名前加解引用符*

# P20

在学习字符串的输入时，初学者大概会迷惑，为什么字符串是一个字符数组，而且输入时不需要取地址符&，而且可以直接用数组名。
现在我们知道字符数组名在此处被解释为字符指针。
scanf将一串字符连续放置到该地址开始的一段空间，并在末尾添加‘\0’表示字符串的结束。
所以，字符串其实就是满足规范的字符数组，当你将一段空间上的数据解释为字符串时，机器会一直遍历这段数据直到遇到’\0’，这也是为什么我们以文本编码形式查看非文本文件时常常看到乱码。


# P24

与面向对象语言提供的“引用”不同，指针允许算数运算。
指针与整数做加法是根据指向对象的大小对地址施加偏移（幸运的是，此处并没有隐式类型转换，对象不是整数编译器一般都会报错）
相同类型的指针之间做减法得到两个指针之间差了几个指向类型的对象（有正负）（幸运的是，此处也没有隐式类型转换，指针类型不同编译器一般都会报错）

# P26

现在我们知道，数组名常常被解释为常量指针，且该指针指向的空间连续分布着数组元素。
那么，如果我们让指针指向数组起始位置，施加对应的偏移量，是否就可以等效的实现数组的元素访问，或者说，数组对元素的访问在底层上是否就是对地址施加偏移？

# P27

事实上，[]和->一样，都是一种后缀运算符，与指针运算确实存在等价关系。
也就是说a[x][y]=*(*(a+x)+y)
乍一看，a被解释为了指向指针的指针（即**）
但如果仅是如此，上述运算等价于（uintptr_t，一种用于将指针转为无符号数的类型）
Type *ptr=(Type*)a;
a[x][y]=*((uintptr_t)ptr+x*sizeof(Type *)+y*sizeof(Type))
直观感受，这不仅不能对应N*M个元素而且空间分配甚至有所重叠

暂时将这个问题搁置，数组名无论被解释为什么，以其为开头的地址对应的一段空间分布着数组元素，那么，如果我们以Type*去访问这段空间，数组元素是如何排布的呢？
C语言中数组空间分配方式被称为行优先。俗话说先行后列，也就是先按靠左的维度量级均分空间。
例如对于Type a[N][M]，先将空间整体均分为N份，每份大小为sizeof(Type)*M，然后在将每份分为M份。

# P29&30&31

结合[]的定义，为了让数组访问元素时得到正确的偏移量，我们得到了新的指针定义方式
Type (*ptr)[M] 指该指针指向的空间区域分布着M个Type类型数据。
注意此处的括号，是为了将指针数组与指向数组的指针做区分
对解释器而言，主要的不同在于
ptr+1=(Type *)((uintptr_t)ptr+M*sizeof(Type))
同理，对于Type *ptr[N][M],ptr+1=(Type *)((uintptr_t)ptr+N*M*sizeof(Type))
在定义指针时M可以为空,表示数量未知，如Type *ptr[] ，当任意一维按此法定义对该指针做整数加法都属于UB

# P34

虽然数组名常常被解释为指针，但是其本身并不是指针
首先它不能被修改
其次将其作为sizeof的参数时，返回的是数组所占空间大小

# 35

与作为函数返回值类型的void不同，void指针的void不是什么都没有，当然也不像这张图中真的一定指向名为虚无的类型。
此处的void表示不限定指针指向类型，该指针可以指向任意类型的数据。
因此，Void* 被认为是一种通用指针。
当你需要一个东西去指向某个地址，但是你不知道或还不知道这片地址实际上存储着什么类型的信息，那么你可以用void*去记录这片地址。
虽然能过编译，但请不要对void相关的指针进行加法运算或减法运算，因为void相关类型的size是UB的

# P38

指针指向的是地址，指针的类型决定了解读以该地址开头的一段空间的方式。
那么指针之间的显式类型转换没有任何限制，但是转换得到的指针可能会引发错误：
指向常量的指针转换为指向非常量的指针导致修改常量的行为发生
指向短类型的指针转换为指向长类型的指针导致访问非法内存

# P44
在结构体定义下的变量被称为该结构体的成员
结构体通过.号访问其成员变量
除此之外在使用上与其他变量无异
这便是一种抽象，你不需要知道结构体这一特性是如何实现的，你只需要知道怎么用就好。
当然，下面我们仍然会介绍，结构体的内部实现

# P45
指向结构体的指针依旧是指向结构体所在空间然后去解释这片空间的内容，定义与其他类型无异。

# P46
与其他类型一样，结构体申请了一片空间，并对这片空间做出了解释，只是结构体在一片空间中解释了多个变量。为此，编译器在解释结构体时，需要计算各个成员从基址开始的偏移量，将基址施加偏移量后的地址解释为该成员变量的地址。
出于内存访问效率要求，结构体的各个成员还存在内存对齐要求。这导致结构体的大小有时不等于各个成员大小之和。此处供感兴趣的同学自行了解。

# P47
然而，出于计算机底层的一些原因，一切并没有这么简单,结构体的内存分配，实际复杂！
我们需要进行内存对齐才能获取对结构体成员更高效的访问。
未来同学们可能会学习相关知识，此处不再展开

# P49
在计算机中，内存是分层级的，效率越高的内存数量越稀少，反之亦然。在x86_64架构下，仅有六个寄存器用于传递函数参数，而且每个寄存器仅能容纳64bit的数据。也就是说，当你调用超过六个参数时，会有参数不通过寄存器传递，导致程序效率变低。这些多余的参数会放置在名为栈的一片内存区域，也是通过记录偏移量来访问这些参数。
对于结构体而言，如果你传递的是结构体指针，那么可以存放于寄存器内。但是如果传递的是结构体本身，它大概率是放在堆栈中的，因为寄存器无法容纳其大小。
然而！编译器对你的代码有着最终解释权。就算你传递的是结构体本身，编译器确信你的代码没有没有对结构体修改于是解释为传递指针。又或者你的结构体成员很少，于是编译器将其拆分到多个寄存器进行传递。

# P52
继续回到杭电程序设计基础的经典问题，学生管理系统。假设学生总数为1000000，但是班级数目最大为100000，且不限制每个班级拥有的学生数量。
此时我们发现，静态的数组已经无法满足我们的需求，定义一个学生数量✖️班级数量的数组是不可行的。
这时，我们就需要动态内存申请，在C语言中我们常用malloc或calloc或realloc。今天我们着重来讲malloc

# P54
想要为什么类型什么数量的数据动态申请空间，只需要计算出其总共需要多大的空间并传入参数，随后用对应类型的指针去保存即可。
不难发现，此时我们的指针不再是某个变量的“别名”而是作为空间的“索引”存在，为程序管理着我们的内存空间。

# P56
只要在之后的程序中，有指针能访问某片空间，或者指针指向的空间存放的指针指向某片空间。则称这片空间是被有效利用的，反之则称之为垃圾。
内存空间是计算机宝贵的资源，如果我们不能回收垃圾，尤其是对于一个长期运行的程序，这将会导致内存泄露，降低可用内存数量，从而导致机器运行效率断崖式下降。
对于大多数现代编程语言，如Java、Python等，都有着自带的垃圾回收器，能够自动检测不再可访问的内存区域并将其释放。
然而C语言中，需要我们手动释放空间，否则所有的垃圾只会到程序结束的时候释放。理论上来讲这会带来更高的时间效率与空间效率（垃圾回收器常常是保守的），只要你有良好的代码习惯，变量随用随放，然而大多数时候只会带来花样百出的内存泄露问题。

# P57
对于大多数现代编程语言，如Java、Python等，都有着自带的垃圾回收器，能够自动检测不再可访问的内存区域并将其释放。
然而C语言中，需要我们手动释放空间，否则所有的垃圾只会到程序结束的时候释放。理论上来讲这会带来更高的时间效率与空间效率（垃圾回收器常常是保守的），只要你有良好的代码习惯，变量随用随放，然而大多数时候只会带来花样百出的内存泄露问题。

# P60

指针是一个强大的工具，提供了程序员与底层交互的可能性，打破了一定的抽象障碍。
但同时，莫大的权限也带来了许多问题，下面我们将介绍几类。

# P64 

与前面几个指针不同，空指针的存在是合理的，但是解引用空指针会引发错误。
事实上，保持未利用的指针是空指针有助于你的调试。假设一个值错误的指针恰好对应了某个可调用的区域，污染了某个区域的数据，你可能会在相隔这个指针甚远的区域发现这个错误而且无法与这个指针产生联系，这是相当致命的。

# P65

指针是管理内存的工具，假设我们现在有多个同类别的对象在不同的代码段申请了动态空间，我们有遍历这些元素的需求，我们该如何统一管理这些指针以便于我们访问呢？
聪明的同学可能会想到，让我们开一个数组来存指针吧🤓☝
为了解决这一需求，我们提出了一种数据结构——链表

# P66
使用链表存储数据，不强制要求数据在内存中连续存储，各个元素可以分散存储在内存中。
这完美满足了动态申请内存的过程中，用一点申请一点，而且无法保证各个部分空间连续的特点
让我们从需求出发，思考链表的数据节点需要哪些成员。下面以双端链表为例，学会双端就啥链表都会了。
首先是数据本身，可能有多个，我们统称为data
接下来我们需要记录这个节点之后的节点是谁，设为nxt
同理我们需要知道这个节点之前的节点，设为pre
我们申请空间时会得到一个指向该空间的指针，所以pre和nxt的类型也是指针，指向相邻节点的地址

# P68

当我们需要遍历链表时，肯定需要有一个起点，我们称这个起点为头指针，指向最靠前的节点，该节点的pre为NULL
当我们向链表插入节点时，没有特殊的要求时会将其插入到尾部，也就是最后一个节点之后，指向该节点的指针成为尾指针，该节点的nxt为null
最好初始化




