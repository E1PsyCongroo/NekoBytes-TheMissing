# P17

指针的一个功能就是充当变量的“别名”
通过指针储存的地址可以修改指向变量的值，那么解引用符*可以获取这个地址空间对应指针类型的值。例如：
看起来有些奇怪？
为什么地址靠前的部分显示了
数位靠低的数据？
请自行了解大端序与小端序😊

# P18

现在我们知道了，一个指针通常对应了两个值：指针本身指向的地址与指向地址处的数据。
这意味着我们对指针赋值时需要区分需要修改的是哪个值
对于前者我们直接使用指针名，而后者需要在指针名前加解引用符*

# P20

在学习字符串的输入时，初学者大概会迷惑，为什么字符串是一个字符数组，而且输入时不需要取地址符&，而且可以直接用数组名。
现在我们知道字符数组名在此处被解释为字符指针。
scanf将一串字符连续放置到该地址开始的一段空间，并在末尾添加‘\0’表示字符串的结束。
所以，字符串其实就是满足规范的字符数组，当你将一段空间上的数据解释为字符串时，机器会一直遍历这段数据直到遇到’\0’，这也是为什么我们以文本编码形式查看非文本文件时常常看到乱码。


# P24

与面向对象语言提供的“引用”不同，指针允许算数运算。
指针与整数做加法是根据指向对象的大小对地址施加偏移（幸运的是，此处并没有隐式类型转换，对象不是整数编译器一般都会报错）
相同类型的指针之间做减法得到两个指针之间差了几个指向类型的对象（有正负）（幸运的是，此处也没有隐式类型转换，指针类型不同编译器一般都会报错）

# P26

现在我们知道，数组名常常被解释为常量指针，且该指针指向的空间连续分布着数组元素。
那么，如果我们让指针指向数组起始位置，施加对应的偏移量，是否就可以等效的实现数组的元素访问，或者说，数组对元素的访问在底层上是否就是对地址施加偏移？

# P27

事实上，[]和->一样，都是一种后缀运算符，与指针运算确实存在等价关系。
也就是说a[x][y]=*(*(a+x)+y)
乍一看，a被解释为了指向指针的指针（即**）
但如果仅是如此，上述运算等价于（uintptr_t，一种用于将指针转为无符号数的类型）
Type *ptr=(Type*)a;
a[x][y]=*((uintptr_t)ptr+x*sizeof(Type *)+y*sizeof(Type))
直观感受，这不仅不能对应N*M个元素而且空间分配甚至有所重叠

暂时将这个问题搁置，数组名无论被解释为什么，以其为开头的地址对应的一段空间分布着数组元素，那么，如果我们以Type*去访问这段空间，数组元素是如何排布的呢？
C语言中数组空间分配方式被称为行优先。俗话说先行后列，也就是先按靠左的维度量级均分空间。
例如对于Type a[N][M]，先将空间整体均分为N份，每份大小为sizeof(Type)*M，然后在将每份分为M份。
