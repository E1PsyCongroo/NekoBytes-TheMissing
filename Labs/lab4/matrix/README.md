# 问题描述

在之前的学习中我们学习使用了二维数组

在线性代数中也存在与二维数组极其相似的结构——矩阵

矩阵是一个按照矩形排列的数字、符号或表达式的集合，通常用于表示线性方程组、变换和数据。

一个矩阵 $ A $ 是一个由 $ m $ 行和 $ n $ 列组成的数组，可以表示为：

$$
A = \begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
$$

其中 $ a_{ij} $ 表示矩阵中第 $ i $ 行第 $ j $ 列的元素。

显然，我们可以用二维数组来存储矩阵

同时，线性代数中对矩阵之间的乘法做出了描述

给定两个矩阵 $ A $ 和 $ B $，它们的乘积 $ C = AB $ 定义为：

如果 $ A $ 是一个 $ m \times n $ 矩阵，$ B $ 是一个 $ n \times p $ 矩阵，则它们的乘积 $ C $ 是一个 $ m \times p $ 矩阵。

矩阵 $ C $ 的元素 $ C_{ij} $ 由以下公式计算：

$$
C_{ij} = \sum_{k=1}^{n} A_{ik} B_{kj}
$$

考虑以下两个矩阵：

$$
A = \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}, \quad
B = \begin{bmatrix}
5 & 6 \\
7 & 8
\end{bmatrix}
$$

它们的乘积 $ C = AB $ 为：

$$
\begin{align*}
C &= \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix}
\begin{bmatrix}
5 & 6 \\
7 & 8
\end{bmatrix} \\
&= \begin{bmatrix}
1 \cdot 5 + 2 \cdot 7 & 1 \cdot 6 + 2 \cdot 8 \\
3 \cdot 5 + 4 \cdot 7 & 3 \cdot 6 + 4 \cdot 8
\end{bmatrix} \\
&= \begin{bmatrix}
19 & 22 \\
43 & 50
\end{bmatrix}
\end{align*}
$$

在本实验中，矩阵的行与列在64以内，矩阵元素为小于100的正整数

# 算法描述

对于矩阵乘法，朴素的迭代算法实现如下：

```c
for (i = 0; i < A.r; i++) {
  for (j = 0; j < B.c; j++) {
    for (k = 0; k < A.c; k++) {
      C[i][j] += A[i][k] * B[k][j];
    }
  }
}
```

显然,这个算法的时间复杂度是$O(n^3)$

那么这个问题有没有算法能达到更优的复杂度呢？

1969年Volker Strassen设计了一种递归的矩阵乘法，达到了约$O(n^{2.8047})$

算法流程如下

首先对矩阵做如下分割，为了实现的方便，我们将所有矩阵扩展到行列皆为相同2的幂次

$$
\begin{align*}
\begin{bmatrix}
C_{11} & C_{12} \\
C_{21} & C_{22}
\end{bmatrix}
&=
\begin{bmatrix}
A_{11} & A_{12} \\
A_{21} & A_{22}
\end{bmatrix}
\begin{bmatrix}
B_{11} & B_{12} \\
B_{21} & B_{22}
\end{bmatrix}
\end{align*}
$$

例如对于五行七列的矩阵A乘以七行二列的矩阵B，我们将两个矩阵都扩展至八行八列，不足的数字用零填充，显然这不会影响结果

这时你可能会疑惑，这种明目张胆拉慢程序速度的行为，算法怎么会允许呢？

然而，这的确没有影响算法的时间复杂度，哪怕这样扩大矩阵，问题的规模依旧是"n"🤓

算法理论的世界没有常数🤓

当前矩阵无法分割时，也就是当前运算的矩阵皆为一行一列，此时直接进行运算

之后，我们做如下操作：

$$
\begin{align*}
M_1 &= A_{11}(B_{12} - B_{22}) \\
M_2 &= (A_{11} + A_{12})B_{22} \\
M_3 &= (A_{21} + A_{22})B_{11} \\
M_4 &= A_{22}(B_{21} - B_{11}) \\
M_5 &= (A_{11} + A_{22})(B_{11} + B_{22}) \\
M_6 &= (A_{12} - A_{22})(B_{21} + B_{22}) \\
M_7 &= (A_{11} - A_{21})(B_{11} + B_{12})
\end{align*}
$$

该过程中的乘法递归调用完成，也就是该函数调用了自己七次

最后对子问题的解进行合并

$$
\begin{align*}
C_{11} &= M_5 + M_4 - M_2 + M_6 \\
C_{12} &= M_1 + M_2 \\
C_{21} &= M_3 + M_4 \\
C_{22} &= M_5 + M_1 - M_3 - M_7
\end{align*}
$$

# 实验要求

想必上面的流程一定让你心生疑问🤔

例如矩阵之间的加减法如何实现，如何扩展和还原矩阵

还记得在lecture中提到过的函数的抽象性吗？

本次lab提供了matrix_functions.h

其中包含了矩阵运算相关的函数，你所需要做的仅仅只是在该递归函数中调用现存的函数！

打开matrix_functions.h，阅读其中函数的功能

打开matrix_multiply.c，完善SMM(Strassen Matrix Multiplication)函数

运行judge.sh验证程序的正确性

你可以自由地仿照testcases下的数据格式添加你的数据进行测试

# 注意事项

1. 请勿修改除_处以外的任何代码
   
# 提示

按照算法流程调用现成函数即可