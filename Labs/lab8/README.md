<div align="center">
  <img src="https://cdn.xyxsw.site/hdu-cs-wiki%20full.svg" alt="logo" width="450rem" height="450rem"/>
</div>

## 1. 项目总览

本次任务是实现一个简单的一元线性回归模型。我们将通过以下几个主要步骤来完成任务：

* **读取CSV文件**：实现一个函数 read_csv 来读取指定列的数据。

* **计算回归系数和截距**：实现几个函数来计算线性回归模型的斜率和截距。

### 编译与使用
在开始前，请先输入以下命令来安装测试库

    apt-get install libcriterion-dev

请在本主目录下按照以下方式构建程序

    make
运行主程序：

    ./main
运行测试：

    ./test

***

## 2.代码实现

### read_csv:

打开路径为file_path的文件，读取从start_row行开始的num_rows行，第col列的数据，返回一个Data。

可能用到的函数：

* fopen
* fclose
* malloc
* strtok
* atof

### calculate_slope:

计算线性回归模型的斜率。
在一元线性回归中，斜率（Slope, \(\beta_1\)）的计算公式为：

\[
\beta_1 = \frac{\sum_{i=1}^{n} (x_i - \bar{x})(y_i - \bar{y})}{\sum_{i=1}^{n} (x_i - \bar{x})^2}
\]

其中：
- \( x_i \) 是第 \( i \) 个数据点的自变量值。
- \( y_i \) 是第 \( i \) 个数据点的因变量值。
- \( \bar{x} \) 是自变量 \( x \) 的平均值。
- \( \bar{y} \) 是因变量 \( y \) 的平均值。
- \( n \) 是数据点的数量。

Data结构体是一个二维数组，但在目前，我们只需要一维的数据，所以我们在实现一元一次回归时默认Data的列数为1。

计算平均数可以使用average函数。

### calculate_intercept:

计算线性回归模型的截距。
在一元线性回归中，截距（Intercept, \(\beta_0\)）的计算公式为：

\[
\beta_0 = \bar{y} - \beta_1 \cdot \bar{x}
\]

其中：
- \( \beta_1 \) 是斜率。
- \( \bar{x} \) 是自变量 \( x \) 的平均值。
- \( \bar{y} \) 是因变量 \( y \) 的平均值。

完成这个函数后你应该可以通过第一个测试了

### 多元多次的线性回归

接下来我们要实现多元多次的线性回归

 <span style="color: red;">下面的内容大量涉及数学，如果不想看可以直接看公式</span>

## 多元多次线性回归的矩阵方法

### 1. 线性回归模型

在多元线性回归中，模型可以表示为：

\[ 
y = X\beta + \epsilon 
\]

其中：
- \( y \) 是因变量的向量。
- \( X \) 是设计矩阵，包括所有自变量。
- \( \beta \) 是回归系数的向量。
- \( \epsilon \) 是误差向量。

### 2. 设计矩阵 \( X \)

设计矩阵可以表示为：

\[
X = \begin{bmatrix}
1 & x_{11} & x_{12} & x_{11}^2 & x_{12}^2 & x_{11}x_{12} & \cdots \\
1 & x_{21} & x_{22} & x_{21}^2 & x_{22}^2 & x_{21}x_{22} & \cdots \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \ddots \\
1 & x_{n1} & x_{n2} & x_{n1}^2 & x_{n2}^2 & x_{n1}x_{n2} & \cdots \\
\end{bmatrix}
\]

### 3. 回归系数的估计

通过最小二乘法，我们估计回归系数：

\[
\hat{\beta} = (X^TX)^{-1}X^Ty
\]

### 4. 推导过程

我们需要最小化误差平方和（残差平方和）：

\[
S(\beta) = (y - X\beta)^T(y - X\beta)
\]

展开这个目标函数：

\[
= y^Ty - 2\beta^TX^Ty + \beta^TX^TX\beta
\]

对 \(\beta\) 求导，并设导数为零：

\[
\frac{\partial S}{\partial \beta} = -2X^Ty + 2X^TX\beta = 0
\]

解方程：

\[
X^TX\beta = X^Ty
\]

假设 \(X^TX\) 可逆：

\[
\beta = (X^TX)^{-1}X^Ty
\]

### 5. 预测

对新的数据点的预测为：

\[
\hat{y} = X_{\text{new}}\hat{\beta}
\]


我已经帮你完成了绝大部分内容，需要完成的是create_X函数
此函数返回一个设计矩阵。

完成此函数的方法有很多，你可以不按顺序填充此矩阵，只要确保最后所有变量的组合都
在矩阵中且不重复就行。

这里提供一种思路：设计一个函数，输入一组数和最大次数，返回所有的组合情况，再用这个函数去完成create_X。我声明了这个函数generate_combinations，当然你可以不实现这个函数，直接用你自己的方法。
比如 输入 2,3和最大次数2,返回
1 (0次)
2,3(一次)
6,4,9(二次)
(或许递归在这里特别好用)


完成这个函数后你应该可以通过第二个测试了
***

## 3.测试


    ./test

我提供的测试非常简单，你可以根据需要自己编写测试

## 运行

完成测试后就可以运行主程序了：

    ./main

这里我们使用了波士顿房价数据来做测试。选用了三个变量，最大次数选择了两次。
可以看到多元多次的效果比一元一次的效果要好不少。

但是我们完成的代码也有不少问题
现在发现的问题有次数不能选太高，选择3时效果变得非常差，可能是由于有些数据太大，或者太小，所以在做矩阵运算时容易出现问题。同时也不能选择太接近0的数据作为输入数据，不然会出现nan。